fun main(args: Array<String>) {
    //lambda takes only one parameter and returns x + 5
//    val addFive:(Int) -> Int = {it + 5} //equivalent to {x -> x + 5}
//    //NB: you can only use the 'it' syntax where the compiler can infer the type
//
//    //no parameters, -> can be omitted
//    {"Pow!"}
//    //invoking lambdas
//    //lambda takes two parameters and returns x + y
//    val addInt:(Int,Int )-> Int = {x:Int,y:Int-> x + y}
//    //one way
//    //val results = addInts.invoke(6,7)
//    //println(results)
//    //another way
//    //val secondResult = addInts(2,4)
//    //println(secondResult)
//    //function type
//    val msg = {x:Int -> "The value is $x"}
//    var sayMsg =  msg(4)
//    println(sayMsg)
//    val name = {name:String -> "My name is $name"}
//    var sayName = name("Michael")
//    println(sayName)
//    //explicitly defining a variable type
//    val add:(Int,Int) -> Int
//    add = {x:Int,y:Int -> x + y}
//    var addUp = add(4,5)
//    println(addUp)
//    //no parameters
//    val greeting:() -> String
//    greeting = {"Hello"}
//    var sayGreeting = greeting()
//    println(sayGreeting)
//    //initializing
//    val secondgreeting:() -> String =  {"Second greeting"}
    //No parameters and return type
//    val myLambda: () -> Unit = {println("I have no parameters and no return type")}
//    var printMyLamba = myLambda()
//    println(printMyLamba)
//    val  name = "Michael"
//    val age = 20
//    val details = {name:String,age:Int -> "Name:$name\nAge:$age"}
//    val calculation:(Int,Int) -> Int = {x,y -> x + y}
//    var sayCalculation = calculation(1,2)
//    println(sayCalculation)
}

